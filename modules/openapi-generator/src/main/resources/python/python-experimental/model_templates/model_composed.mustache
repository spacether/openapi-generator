class {{classname}}(ModelComposed):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.

    Attributes:
{{> python-experimental/model_templates/docstring_allowed }}
      attribute_map (dict): The key is attribute name
          and the value is json key in definition.
      discriminator_value_class_map (dict): A dict to go from the discriminator
          variable value to the discriminator class name.
{{> python-experimental/model_templates/docstring_openapi_validations }}
    """

    allowed_values = {
{{#vars}}
{{#isEnum}}
        ('{{name}}',): {
{{#isNullable}}
            'None': None,
{{/isNullable}}
{{#allowableValues}}
{{#enumVars}}
            '{{name}}': {{{value}}},
{{/enumVars}}
{{/allowableValues}}
        },
{{/isEnum}}
{{/vars}}
    }

    validations = {
{{#isAlias}}
{{^isEnum}}
{{^isArrayModel}}
        ('value',): {
{{> python-experimental/model_templates/validations }}
{{/isArrayModel}}
{{/isEnum}}
{{/isAlias}}
{{#requiredVars}}
{{#hasValidation}}
        ('{{name}}',): {
{{> python-experimental/model_templates/validations }}
{{/hasValidation}}
{{/requiredVars}}
{{#optionalVars}}
{{#hasValidation}}
        ('{{name}}',): {
{{> python-experimental/model_templates/validations }}
{{/hasValidation}}
{{/optionalVars}}
    }

{{#additionalPropertiesType}}
    @cached_property
    def additional_properties_type():
        """
        This must be a method because a model may have properties that are
        of type self, this must run after the class is loaded
        """
{{#imports}}
{{#-first}}
        lazy_import()
{{/-first}}
{{/imports}}
        return ({{{additionalPropertiesType}}},)  # noqa: E501
{{/additionalPropertiesType}}
{{^additionalPropertiesType}}
    additional_properties_type = None
{{/additionalPropertiesType}}

    _nullable = {{#isNullable}}True{{/isNullable}}{{^isNullable}}False{{/isNullable}}

    @cached_property
    def openapi_types():
        """
        This must be a method because a model may have properties that are
        of type self, this must run after the class is loaded

        Returns
            openapi_types (dict): The key is attribute name
                and the value is attribute type.
        """
{{#imports}}
{{#-first}}
        lazy_import()
{{/-first}}
{{/imports}}
        return {
{{#vars}}
            '{{name}}': ({{{dataType}}},),
{{/vars}}
        }

    @cached_property
    def discriminator():
{{^discriminator}}
        return None
{{/discriminator}}
{{#discriminator}}
{{#mappedModels}}
{{#-first}}
{{#imports}}
{{#-first}}
        lazy_import()
{{/-first}}
{{/imports}}
{{/-first}}
{{/mappedModels}}
        val = {
{{#mappedModels}}
            '{{mappingName}}': {{{modelName}}},
{{/mappedModels}}
        }
        if not val:
            return None
        return {'{{{discriminatorName}}}': val}{{/discriminator}}

    attribute_map = {
{{#vars}}
        '{{name}}': '{{baseName}}',  # noqa: E501
{{/vars}}
    }


{{> python-experimental/model_templates/method_init_composed }}

    @cached_property
    def _composed_schemas():
        # we need this here to make our import statements work
        # we must store _composed_schemas in here so the code is only run
        # when we invoke this method. If we kept this at the class
        # level we would get an error beause the class level
        # code would be run when this module is imported, and these composed
        # classes don't exist yet because their module has not finished
        # loading
{{#imports}}
{{#-first}}
        lazy_import()
{{/-first}}
{{/imports}}
        return {
          'anyOf': [
{{#anyOf}}
              {{{.}}},
{{/anyOf}}
          ],
          'allOf': [
{{#allOf}}
              {{{.}}},
{{/allOf}}
          ],
          'oneOf': [
{{#oneOf}}
              {{{.}}},
{{/oneOf}}
          ],
        }